## class definitions that depend on the proxies to Python classes
## and need to come after proxyClasses.R in collation order

SpeechList <- setRefClass("SpeechList", contains = "list_Python")

SpeechList$methods(
    show = function() {
        plays <- unlist(allFieldStrings(.self, "playTitle", .get=TRUE))
    cat(gettextf("%s object of size %d; speeches from %s\n",
                 class(.self), size(), paste(dQuote(plays), collapse = ", ")))
    },
    print = function() {
        'this method prints the entire list of speeches; e.g., the whole play, in contrast to the automatic show() method, which prints only a summary.'
        n <- size()
        if(is.na(n)) {
            warning("SpeechList object had NA for the size slot")
            n <- 0
        }
        if(n > 0) {
            playP <- actP <- sceneP <-  ""
            for(i in 0:(n-1)) {
                sp <- el(i)
                if(!is(sp, "Speech_Python")) {
                    warning(gettextf("Element %s is not a Speech object: skipping", i+1))
                    next
                }
                play <- sp$playTitle; act <- sp$act; scene <- sp$scene
                printSpeech(sp, !identical(play, playP), !identical(act, actP),
                            !identical(scene, sceneP), FALSE)
                playP <- play; actP <- act; sceneP <- scene
                cat("\n")
            }
        }
    }
    )

#' A Class for the Python/XML Version of a Play
#'
#' The plays are parsed from the set of XML files into Python \code{"ElementTree"} objects.
#' An R object from class \code{"Play"} has a proxy to the parsed play plus fields for the
#' names of the personae and a proxy to a Python list of all the speeches.
#' This class extends the proxy class for \code{"ElementTree"}.
#'
#' @field personae Character vector of the descriptions of the personae in the play.  Note that this
#' comes from the play itself.  The names of speakers usually match one of the personae in the \code{grep()}
#' sense, but not always.
#' @field title The character string title, as found in the XML representation.
#' @field speeches Proxy for a Python listof all the speeches (each an object
#' of Python class \code{"Speech"}).  This is precomputed when the \code{"Play"} object is initialized;
#' the speeches list tends to be input to many of the interesting analyses.  If you want to suppress
#' precomputation, explicitly set this field to a Python list, as in the example below.
#' @field key The character string identifying the play in the table and also the name of the original XML file.
#' @export
Play <- setRefClass("Play",
                    contains = "ElementTree_Python",
                    fields = c(
                        personae = "character",
                        speeches = "SpeechList",
                        title = "character",
                        key = "character"
                               ))


Play$methods(
    initialize = function(name, ...) {
        if(nargs()) {
            key <<- findPlay(name)
            callSuper(getPlay(key), ...)
            personae <<- unlist(getPersonae(.self))
            title <<- findtext("TITLE")
            speeches <<- SpeechList(getSpeeches(.self))
        }
    }
    )

.abbrevScene <- function(scene) {
    if(grepl("^SCENE ", scene))
        gsub("[.].*","", scene)
    else
        substr(scene, 1, 10)
}

printSpeech <- function(speech, showPlay = TRUE, showAct = TRUE, showScene= TRUE, abbrevScene = TRUE) {
    ## either called with a proxy object or a previously converted (and maybe modified) speech
    if(is(speech, "Speech_Python"))
        speech <- pythonGet(speech)
    fields <- speech@fields
    header <- if(showPlay) fields$play else ""
    if(showAct) {
        if(nzchar(header))
            header <- paste0(header,",")
        header <- paste(header, fields$act)
    }
    if(showScene) {
        if(nzchar(header))
            header <- paste0(header,",")
        header <- paste(header, if(abbrevScene) .abbrevScene(fields$scene) else fields$scene)
    }
    if(nzchar(header)) cat(header, "\n")
    cat(fields$speaker, ":\n")
    writeLines(paste("   ",fields$lines))
    invisible(speech)
}

#' Print a List of Speeches or Speech Fragments
#'
#' Given a list of speech objects, print them all.  The list may be a portion
#' of a play (e.g., a scene) or a list of speech fragments generated by
#' \code{\link{searchSpeeches}()} and \code{\link{speechFragments}()}.
#' @param speeches A list of speeches, either a list in Python or the result of getting
#' such an object back to R.
#' @param printSeparator Should a special separator line be printed between speeches.  Generally you would want this if the list was a result of a search, but not
#' to print a contiguous part of the play, e.g., a scene.
printSpeeches <- function(speeches, printSeparator = TRUE) {
    if(is(speeches, "list_Python"))
        speeches <- pythonGet(speeches)
    play <- TRUE
    lastAct <- lastScene <- ""
    for(speech in speeches) {
        if(printSeparator && !identical(lastAct, "")) # separator
            cat("      ------\n")
        if(is(speech, "Speech_Python"))
            speech <- pythonGet(speech)
        fields <- speech@fields
        act <- fields$act; scene <- fields$scene
        last <- printSpeech(speech, play, !identical(act, lastAct),
                            !identical(scene,lastScene), FALSE)
        lastAct <- act; lastScene <- scene; play <- FALSE
    }
}
##TODO:  define a version of the Play class in Python but in native R form
## using the XML package to represent the XML form of the play
    ## setMethod("asServerObject",
    ## c("Play_R", "PythonObject"),
    ##       function(object, prototype) {
    ##           file <- tempfile()
    ##           XML::saveXML(object, file)
    ##           gettextf("xml.etree.ElementTree.parse(%s)",
    ##                    asServerObject(file, prototype))
    ##       })

